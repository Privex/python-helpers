import argparse
import inspect
from decimal import Decimal
from privex.helpers import settings as settings
from privex.helpers.collections import DictObject as DictObject, OrderedDictObject as OrderedDictObject
from privex.helpers.exceptions import NestedContextException as NestedContextException
from privex.helpers.types import C as C, K as K, NumberStr as NumberStr, STRBYTES as STRBYTES, T as T, USE_ORIG_VAR as USE_ORIG_VAR, V as V
from typing import Any, BinaryIO, Callable, Dict, Generator, Iterable, List, Mapping, Optional, Sequence, Tuple, Type, Union

log: Any
SAFE_CHARS: str
ALPHANUM: Any

def random_str(size: int=..., chars: Sequence=...) -> str: ...
def empty(v: Any, zero: bool=..., itr: bool=...) -> bool: ...
def empty_if(v: V, is_empty: K=..., not_empty: T=..., **kwargs: Any) -> Union[T, K, V]: ...
def is_true(v: Any) -> bool: ...
def is_false(v: Any, chk_none: bool=...) -> bool: ...
def parse_keyval(line: str, valsplit: str=..., csvsplit: Any=...) -> List[Tuple[str, str]]: ...
def parse_csv(line: str, csvsplit: str=...) -> List[str]: ...
def env_csv(env_key: str, env_default: Any=..., csvsplit: Any=...) -> List[str]: ...
def env_keyval(env_key: str, env_default: Any=..., valsplit: Any=..., csvsplit: Any=...) -> List[Tuple[str, str]]: ...
def env_cast(env_key: str, cast: callable, env_default: Any=...) -> Any: ...
def env_bool(env_key: str, env_default: Any=...) -> Union[bool, None]: ...
def env_int(env_key: str, env_default: Any=...) -> int: ...
def env_decimal(env_key: str, env_default: Any=...) -> Decimal: ...
def extract_settings(prefix: str, _settings: Any=..., defaults: Any=..., merge_conf: Any=..., **kwargs: Any) -> dict: ...
def get_return_type(f: callable) -> Optional[Union[type, object, callable]]: ...
def typing_to_base(tp: Any, fail: Any=..., return_orig: Any=..., clean_union: Any=...) -> Optional[Union[type, object, callable, tuple, Tuple[type]]]: ...
def extract_type(tp: Union[type, callable, object], **kwargs: Any) -> Optional[Union[type, object, callable, tuple, Tuple[type]]]: ...
def dec_round(amount: Decimal, dp: int=..., rounding: Any=...) -> Decimal: ...
def chunked(iterable: Any, n: Any): ...
def inject_items(items: list, dest_list: list, position: int) -> List[str]: ...
def byteify(data: Optional[Union[str, bytes]], encoding: Any=..., if_none: Any=...) -> bytes: ...
def stringify(data: Optional[Union[str, bytes]], encoding: Any=..., if_none: Any=...) -> str: ...

class ErrHelpParser(argparse.ArgumentParser):
    def error(self, message: Any) -> None: ...

first_cap_re: Any
all_cap_re: Any

def camel_to_snake(name: STRBYTES) -> str: ...
def human_name(class_name: Union[str, bytes, callable, Type[object]]) -> str: ...
def shell_quote(*args: str) -> str: ...
def call_sys(proc: Any, *args: Any, write: STRBYTES=..., **kwargs: Any) -> Union[Tuple[bytes, bytes], Tuple[str, str]]: ...
def reverse_io(f: BinaryIO, blocksize: int=...) -> Generator[bytes, None, None]: ...
def io_tail(f: BinaryIO, nlines: int=..., bsz: int=...) -> Generator[List[str], None, None]: ...
def tail(filename: str, nlines: int=..., bsz: int=...) -> List[str]: ...
def filter_form(form: Mapping, *keys: Any, cast: callable=...) -> Dict[str, Any]: ...
def almost(compare: NumberStr, *numbers: NumberStr, tolerance: NumberStr=..., **kwargs: Any) -> bool: ...

IS_XARGS: Any
IS_XKWARGS: Any
T_PARAM = inspect.Parameter
T_PARAM_LIST = Union[Dict[str, T_PARAM], Mapping[str, T_PARAM], List[T_PARAM], Iterable[T_PARAM]]
INS_EMPTY: Any
T_PARAM_DICT = Union[Dict[str, T_PARAM], DictObject, Dict[type, Dict[str, T_PARAM]]]

def get_function_params(obj: Union[type, callable], check_parents: Any=..., **kwargs: Any) -> T_PARAM_DICT: ...
def construct_dict(cls: Union[Type[T], C], kwargs: dict, args: Iterable=..., check_parents: Any=...) -> Union[T, Any]: ...

class LayeredContext:
    wrapped_class: K
    layer_contexts: List[Any]
    current_context: Optional[Union[K, Any]]
    layer: int
    virtual_layer: int
    max_layers: Optional[int]
    fail: bool
    def __init__(self, wrapped_class: K, max_layers: Optional[int]=..., fail: bool=...) -> None: ...
    @property
    def class_name(self): ...
    def enter(self) -> Union[K, Any]: ...
    def exit(self, exc_type: Any=..., exc_val: Any=..., exc_tb: Any=...) -> Any: ...
    async def aenter(self) -> Union[K, Any]: ...
    async def aexit(self, exc_type: Any=..., exc_val: Any=..., exc_tb: Any=...) -> Any: ...
    def __enter__(self) -> Union[K, Any]: ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> Any: ...
    async def __aenter__(self) -> Union[K, Any]: ...
    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> Any: ...

def strip_null(value: Union[str, bytes], conv: Callable[[str], Union[str, bytes, T]]=..., nullc: Any=...) -> Union[str, bytes, T]: ...
