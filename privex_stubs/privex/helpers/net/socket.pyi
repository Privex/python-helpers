import asyncio
import socket
import ssl
from privex.helpers.thread import SafeLoopThread
from privex.helpers.types import AnyNum, STRBYTES, T
from typing import Any, Callable, Generator, IO, Iterable, List, Optional, Tuple, Union

AnySocket: Any
OpAnySocket: Any

class SocketContextManager:
    parent_class: Union[SocketWrapper, AsyncSocketWrapper]
    def __init__(self, parent_class: Union[SocketWrapper, AsyncSocketWrapper]) -> None: ...
    def __enter__(self) -> SocketWrapper: ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    async def __aenter__(self) -> AsyncSocketWrapper: ...
    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...

class StopLoopOnMatch(Exception):
    message: Any = ...
    match: Any = ...
    compare: Any = ...
    compare_lower: Any = ...
    extra: Any = ...
    def __init__(self, message: str, match: Any=..., compare: str=..., compare_lower: bool=..., **extra: Any) -> None: ...

class MockContext:
    def __enter__(self): ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    async def __aenter__(self): ...
    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...

class SocketTracker:
    host: str = ...
    port: int = ...
    timeout: Union[int, float] = ...
    server: bool = ...
    connected: bool = ...
    binded: bool = ...
    listening: bool = ...
    use_ssl: bool = ...
    socket_conf: dict = ...
    ssl_conf: dict = ...
    ssl_wrap_conf: dict = ...
    hostname: str = ...
    def __attrs_post_init__(self) -> None: ...
    @property
    def family(self) -> int: ...
    @family.setter
    def family(self, value: int) -> Any: ...
    @property
    def host_v4(self) -> Optional[str]: ...
    @property
    def host_v6(self) -> Optional[str]: ...
    @property
    def socket(self): ...
    @socket.setter
    def socket(self, value: Any) -> None: ...
    @property
    def socket_layer_ctx(self): ...
    @socket_layer_ctx.setter
    def socket_layer_ctx(self, value: Any) -> None: ...
    @property
    def ssl_context(self): ...
    @ssl_context.setter
    def ssl_context(self, value: Any) -> None: ...
    @property
    def ssl_socket(self): ...
    @ssl_socket.setter
    def ssl_socket(self, value: Any) -> None: ...
    @property
    def loop(self) -> asyncio.AbstractEventLoop: ...
    @property
    def auto_socket(self) -> AnySocket: ...
    @property
    def ip_address(self): ...
    connected_ip: Any = ...
    @property
    def connected_port(self): ...
    def bind(self, address: Tuple[str, AnyNum]=..., force: Any=..., **kwargs: Any) -> Any: ...
    def listen(self, backlog: int=..., force: Any=..., **kwargs: Any) -> Any: ...
    def post_connect(self, sock: AnySocket) -> Any: ...
    def v6_fallback(self, ex: Exception=...) -> bool: ...
    def connect(self, force: Any=..., override_ssl: Any=..., _conn_tries: Any=...) -> AnySocket: ...
    def reconnect(self, force: Any=..., override_ssl: Any=..., _conn_tries: Any=...) -> AnySocket: ...
    async def reconnect_async(self, force: Any=..., override_ssl: Any=..., _conn_tries: Any=...) -> AnySocket: ...
    async def connect_async(self, force: Any=..., override_ssl: Any=..., _conn_tries: Any=...) -> AnySocket: ...
    def disconnect(self): ...
    @classmethod
    def duplicate(cls: Any, inst: SocketTracker, **kwargs: Any) -> SocketTracker: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    async def __aenter__(self): ...
    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    def __getattr__(self, item: Any): ...
    def __init__(self, host: Any, port: Any, timeout: Any, server: Any, connected: Any, binded: Any, listening: Any, use_ssl: Any, socket_conf: Any, ssl_conf: Any, ssl_wrap_conf: Any, hostname: Any, ssl_context: Any, ssl_socket: Any, loop: Any, socket: Any, socket_layer_ctx: Any, host_v4: Any, host_v6: Any, host_v4_resolved: Any, host_v6_resolved: Any) -> None: ...
    def __lt__(self, other: Any) -> Any: ...
    def __le__(self, other: Any) -> Any: ...
    def __gt__(self, other: Any) -> Any: ...
    def __ge__(self, other: Any) -> Any: ...

class SocketWrapper:
    DEFAULT_TIMEOUT: Any = ...
    auto_connect: bool
    auto_listen: bool
    listen_backlog: int
    tracker: SocketTracker
    server: Any = ...
    error_reconnect: Any = ...
    read_timeout: Any = ...
    send_timeout: Any = ...
    def __init__(self, host: str, port: int, server: Any=..., family: Any=..., type: Any=..., proto: Any=..., fileno: Any=..., timeout: Any=..., use_ssl: Any=..., verify_cert: Any=..., **kwargs: Any) -> None: ...
    @property
    def ssl_conf(self) -> dict: ...
    @ssl_conf.setter
    def ssl_conf(self, value: Any) -> None: ...
    @property
    def ssl_wrap_conf(self) -> dict: ...
    @ssl_wrap_conf.setter
    def ssl_wrap_conf(self, value: Any) -> None: ...
    @property
    def socket_conf(self) -> dict: ...
    @socket_conf.setter
    def socket_conf(self, value: Any) -> None: ...
    @property
    def timeout(self): ...
    @timeout.setter
    def timeout(self, value: Any) -> None: ...
    @property
    def hostname(self): ...
    @hostname.setter
    def hostname(self, value: Any) -> None: ...
    @property
    def context(self) -> ssl.SSLContext: ...
    ssl_context: Any = ...
    @property
    def base_socket(self) -> socket.socket: ...
    @base_socket.setter
    def base_socket(self, value: socket.socket) -> Any: ...
    @property
    def socket(self) -> AnySocket: ...
    @socket.setter
    def socket(self, value: AnySocket) -> Any: ...
    @property
    def connected(self): ...
    binded: bool = ...
    def bind(self, host: Union[str, Tuple[str, AnyNum]]=..., port: AnyNum=..., sock: OpAnySocket=..., **kwargs: Any) -> Any: ...
    def connect(self, host: Union[str, Tuple[str, AnyNum]]=..., port: AnyNum=..., sock: OpAnySocket=..., **kwargs: Any) -> AnySocket: ...
    def reconnect(self, host: Union[str, Tuple[str, AnyNum]]=..., port: AnyNum=..., sock: OpAnySocket=..., **kwargs: Any) -> Any: ...
    listening: bool = ...
    def listen(self, backlog: Any=..., sock: OpAnySocket=..., **kwargs: Any) -> Any: ...
    def accept(self, sock: OpAnySocket=..., **kwargs: Any) -> Tuple[AnySocket, Tuple[str, int]]: ...
    def settimeout(self, value: Any, sock: OpAnySocket=..., **kwargs: Any) -> Any: ...
    def close(self, sock: OpAnySocket=...) -> Any: ...
    def recv(self, bufsize: int, flags: int=..., sock: OpAnySocket=..., **kwargs: Any) -> bytes: ...
    def recvfrom(self, bufsize: int, flags: int=..., sock: OpAnySocket=..., **kwargs: Any) -> Tuple[bytes, Any]: ...
    def recvmsg(self, bufsize: int, ancbufsize: int=..., flags: int=..., sock: OpAnySocket=..., **kwargs: Any) -> Tuple[bytes, List[Tuple[int, int, bytes]], int, Any]: ...
    def read_eof(self, bufsize: int=..., eof_timeout: AnyNum=..., flags: int=..., timeout_fail: Any=..., strip: Any=..., conv: Optional[Callable[[Union[bytes, str]], T]]=..., sock: OpAnySocket=..., **kwargs: Any) -> Union[bytes, str, T]: ...
    def shutdown(self, how: int=..., sock: OpAnySocket=..., **kwargs: Any) -> Any: ...
    def send(self, data: Union[str, bytes], flags: int=..., sock: OpAnySocket=..., **kwargs: Any) -> Any: ...
    def sendall(self, data: Union[str, bytes], flags: int=..., sock: OpAnySocket=..., **kwargs: Any) -> Any: ...
    def sendto(self, data: Union[str, bytes], *args: Any, sock: OpAnySocket=..., **kwargs: Any) -> Any: ...
    def send_chunks(self, gen: Union[Iterable, Generator], flags: int=..., sock: OpAnySocket=..., **kwargs: Any) -> Any: ...
    def query(self, data: Union[str, bytes], bufsize: int=..., eof_timeout: Any=..., sock: OpAnySocket=..., **kwargs: Any) -> Any: ...
    def http_request(self, url: Any=..., host: Any=..., method: Any=..., user_agent: Any=..., extra_data: Union[STRBYTES, List[str]]=..., body: STRBYTES=..., eof_timeout: Any=..., bufsize: int=..., conv: Optional[Callable[[Union[bytes, str]], T]]=..., sock: OpAnySocket=..., **kwargs: Any) -> Union[str, bytes, T]: ...
    def setblocking(self, flag: bool, sock: OpAnySocket=..., **kwargs: Any) -> Any: ...
    def handle_connection(self, sock: AnySocket, addr: Tuple[str, int], callback: Callable[[SocketWrapper, Tuple[str, int]], Any], stop_return: Union[str, bytes]=..., **kwargs: Any) -> Any: ...
    def on_connect(self, callback: Callable[[SocketWrapper, Tuple[str, int]], Any], timeout: AnyNum=..., stop_return: Union[str, bytes]=..., **kwargs: Any) -> Any: ...
    class SocketWrapperThread(SafeLoopThread):
        parent_instance: Any = ...
        callback: Any = ...
        conn_kwargs: Any = ...
        stop_return: Any = ...
        stop_compare: Any = ...
        stop_compare_lower: Any = ...
        def __init__(self, *args: Any, parent_instance: SocketWrapper, callback: Any, stop_return: Any, conn_kwargs: dict=..., **kwargs: Any) -> None: ...
        def loop(self) -> None: ...
        def run(self): ...
    def on_connect_thread(self, callback: Callable[[SocketWrapper, Tuple[str, int]], Any], timeout: AnyNum=..., stop_return: Union[str, bytes]=..., daemon: Any=..., auto_start: Any=..., **kwargs: Any) -> SocketWrapperThread: ...
    @classmethod
    def from_socket(cls: Any, sock: AnySocket, server: Any=..., **kwargs: Any) -> Union[SocketWrapper, AsyncSocketWrapper]: ...
    def __getattribute__(self, item: Any): ...
    def __enter__(self): ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any): ...

class AsyncSocketWrapper(SocketWrapper):
    DEFAULT_TIMEOUT: Any = ...
    def __init__(self, host: str, port: int, server: Any=..., family: Any=..., type: Any=..., proto: Any=..., fileno: Any=..., timeout: Any=..., use_ssl: Any=..., verify_cert: Any=..., loop: Any=..., **kwargs: Any) -> None: ...
    @property
    def loop(self) -> asyncio.AbstractEventLoop: ...
    async def connect(self, host: Union[str, Tuple[str, AnyNum]]=..., port: AnyNum=..., sock: OpAnySocket=..., **kwargs: Any) -> AnySocket: ...
    async def reconnect(self, host: Union[str, Tuple[str, AnyNum]]=..., port: AnyNum=..., sock: OpAnySocket=..., **kwargs: Any) -> Any: ...
    async def read_eof(self, bufsize: int=..., eof_timeout: AnyNum=..., flags: int=..., timeout_fail: Any=..., strip: Any=..., conv: Optional[Callable[[Union[bytes, str]], T]]=..., sock: OpAnySocket=..., **kwargs: Any) -> Union[str, bytes, T]: ...
    async def recv(self, bufsize: int, flags: int=..., sock: OpAnySocket=..., timeout: Union[float, int]=..., **kwargs: Any) -> bytes: ...
    async def recv_into(self, buf: bytearray, sock: OpAnySocket=..., **kwargs: Any) -> int: ...
    async def send(self, data: Union[str, bytes], flags: int=..., sock: OpAnySocket=..., timeout: Union[float, int]=..., **kwargs: Any) -> Any: ...
    async def sendall(self, data: Union[str, bytes], flags: int=..., sock: OpAnySocket=..., timeout: Union[float, int]=..., **kwargs: Any) -> Any: ...
    async def sendfile(self, file: IO[bytes], offset: int=..., count: int=..., fallback: bool=..., sock: OpAnySocket=..., timeout: Union[float, int]=..., **kwargs: Any) -> Any: ...
    async def query(self, data: Union[str, bytes], bufsize: int=..., eof_timeout: Any=..., sock: OpAnySocket=..., **kwargs: Any) -> Any: ...
    async def http_request(self, url: Any=..., host: Any=..., method: Any=..., user_agent: Any=..., extra_data: Union[STRBYTES, List[str]]=..., body: STRBYTES=..., eof_timeout: Any=..., bufsize: int=..., conv: Optional[Callable[[Union[bytes, str]], T]]=..., sock: OpAnySocket=..., **kwargs: Any) -> Union[str, bytes, T]: ...
    async def accept(self, sock: OpAnySocket=..., **kwargs: Any) -> Tuple[AnySocket, Tuple[str, int]]: ...
    async def handle_connection(self, sock: AnySocket, addr: Tuple[str, int], callback: Callable[[AsyncSocketWrapper, Tuple[str, int]], Any], stop_return: Union[str, bytes]=..., **kwargs: Any) -> Any: ...
    async def on_connect(self, callback: Callable[[AsyncSocketWrapper, Tuple[str, int]], Any], timeout: AnyNum=..., stop_return: Union[str, bytes]=..., sock: OpAnySocket=..., **kwargs: Any) -> Any: ...
    async def __aenter__(self): ...
    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any): ...

async def send_data_async(host: str, port: int, data: Union[bytes, str, Iterable], timeout: AnyNum=..., **kwargs: Any) -> Optional[Union[str, bytes]]: ...
def send_data(host: str, port: int, data: Optional[Union[bytes, str, Iterable]]=..., timeout: Union[int, float]=..., **kwargs: Any) -> Optional[Union[str, bytes]]: ...
def upload_termbin(data: Union[bytes, str], timeout: Union[int, float]=..., **kwargs: Any) -> str: ...
def upload_termbin_file(filename: str, timeout: int=..., **kwargs: Any) -> str: ...
async def upload_termbin_async(data: Union[bytes, str], timeout: Union[int, float]=...) -> str: ...
async def upload_termbin_file_async(filename: str, timeout: int=...) -> str: ...
