from cryptography.fernet import Fernet
from cryptography.hazmat.primitives.kdf import KeyDerivationFunction
from io import TextIOWrapper
from privex.helpers.common import ALPHANUM as ALPHANUM, empty as empty, random_str as random_str
from privex.helpers.crypto.base import is_base64 as is_base64
from privex.helpers.exceptions import EncryptKeyMissing as EncryptKeyMissing, EncryptionError as EncryptionError
from typing import Any, Optional, Tuple, Type, Union

log: Any

class EncryptHelper:
    encrypt_key: str
    settings: Any = ...
    def __init__(self, encrypt_key: str, **kwargs: Any) -> None: ...
    @staticmethod
    def generate_key(output: Optional[Union[str, TextIOWrapper]]=..., mode: Any=...) -> str: ...
    @staticmethod
    def password_key(password: Any, salt: Any=..., kdf: Type[KeyDerivationFunction]=..., **kwargs: Any) -> Tuple[str, dict]: ...
    @classmethod
    def from_password(cls: Any, password: Union[str, bytes], salt: Union[str, bytes], **settings: Any) -> Any: ...
    @classmethod
    def from_file(cls: Any, obj: Union[str, TextIOWrapper], **settings: Any) -> Any: ...
    def get_fernet(self, key: Union[str, bytes]=...) -> Fernet: ...
    def is_encrypted(self, data: Union[str, bytes], key: Union[str, bytes]=...) -> bool: ...
    def encrypt_str(self, data: Union[str, bytes], key: Union[str, bytes]=...) -> str: ...
    def decrypt_str(self, data: Union[str, bytes], key: Union[str, bytes]=...) -> str: ...
