import abc
from io import BufferedRWPair, BufferedReader, BytesIO
from pathlib import Path
from privex.helpers.asyncx import await_if_needed as await_if_needed, run_coro_thread as run_coro_thread, run_coro_thread_async as run_coro_thread_async
from privex.helpers.collections import DictObject as DictObject
from privex.helpers.common import STRBYTES as STRBYTES, byteify as byteify, empty as empty, empty_if as empty_if, is_true as is_true, stringify as stringify
from privex.helpers.types import EXSTRBYTES as EXSTRBYTES, T as T
from typing import Any, BinaryIO, Callable, Dict, Optional, Tuple, Union

HLHash: Any
log: Any
KB: int
MB: Any
GB: Any
TB: Any

def int_bytes(data: int, endian: Any=...) -> bytes: ...

class Hash(metaclass=abc.ABCMeta):
    digest_size: int
    block_size: int
    name: str
    def copy(self) -> Hash: ...
    def digest(self) -> bytes: ...
    def hexdigest(self) -> str: ...
    def update(self, data: Union[bytes, bytearray, memoryview]) -> Optional[Any]: ...

def wrap_int_hash(f: Any) -> Callable[[Any], bytes]: ...
def crc32(string: Union[str, bytes]=...) -> XHash: ...
def adler32(string: Union[str, bytes]=...) -> XHash: ...
def hashwrap(algo: str) -> Any: ...

md4: Any
md5: Any
sha1: Any
sha224: Any
sha256: Any
sha384: Any
sha512: Any
ripemd160: Any
whirlpool: Any
shake_128: Any
shake_256: Any
HASH_MAP: Dict[str, Callable[[STRBYTES], XHash]]
SUPPORTS_UPDATE: Dict[str, bool]

def supports_update(algo: str, fallback: T=...) -> Union[bool, T]: ...
async def init_hash(algo: str, data: STRBYTES, store_data: Any=..., force_disable_store: Any=..., **kwargs: Any) -> Tuple[XHash, str]: ...

class XHash(Hash):
    digest_size: int
    block_size: int
    name: str
    HASHCLS: Any = ...
    BYTEFUNC: Any = ...
    BYTEFUNCCLS: Any = ...
    hash_class: HASHCLS
    item_act: str
    _cache: Union[Dict[str, Any], DictObject]
    wrapper: Any = ...
    use_cache: Any = ...
    orig_data: bytes = ...
    store_data: bool = ...
    data: Any = ...
    def __init__(self, orig_data: STRBYTES=..., data: Union[bytes, int]=..., wrapper: BYTEFUNCCLS=..., *args: Any, **kwargs: Any): ...
    @property
    def cache(self) -> DictObject: ...
    def copy(self) -> Union[Hash, XHash]: ...
    def digest(self) -> bytes: ...
    def hexdigest(self) -> str: ...
    def update(self, data: Union[bytes, bytearray, memoryview, str]) -> Optional[Any]: ...
    @classmethod
    def from_hashlib(cls: Any, algorithm: str=..., orig_data: STRBYTES=..., **kwargs: Any) -> XHash: ...
    @classmethod
    def from_int_func(cls: Any, orig_data: STRBYTES=..., wrapper: Callable[[bytes], int]=..., data: Union[bytes, int]=..., **kwargs: Any) -> XHash: ...
    def to_dict(self) -> dict: ...
    def to_base64(self, string: Any=..., urlsafe: Any=..., altchars: Optional[bytes]=..., encoding: str=...) -> STRBYTES: ...
    def to_base32(self, string: Any=..., encoding: str=...) -> STRBYTES: ...
    def __add__(self, other: Any): ...
    def __iter__(self) -> Any: ...
    def __index__(self): ...
    def __str__(self) -> str: ...
    def __len__(self): ...
    def __eq__(self, other: Any) -> Any: ...
    def __copy__(self): ...
    def __deepcopy__(self, memodict: Optional[Any] = ...): ...
    def __bytes__(self) -> bytes: ...
    def __repr__(self) -> str: ...
    def __int__(self) -> int: ...
    def __getitem__(self, item: Any) -> None: ...

async def calc_hash(data: STRBYTES, algo: str=..., b64: Any=..., hexdigest: Any=..., **kwargs: Any) -> STRBYTES: ...
def calc_hash_sync(data: STRBYTES, algo: str=..., b64: Any=..., hexdigest: Any=..., **kwargs: Any) -> STRBYTES: ...

FILE_BLOCK_SIZE: Any
MIN_BLOCK_SIZE: Any
BYTES_IO = Union[BytesIO, BinaryIO, BufferedReader, BufferedRWPair]

async def calc_hash_blocks(fh: BYTES_IO, fsize: int, algo: str=..., b64: Any=..., hexdigest: Any=..., **kwargs: Any) -> STRBYTES: ...
async def calc_hash_file(filename: str, algo: str=..., b64: Any=..., hexdigest: Any=..., **kwargs: Any) -> STRBYTES: ...
async def calc_hashes_thread(*data: STRBYTES, algo: str=..., b64: Any=..., hexdigest: Any=..., fail: Any=..., **kwargs: Any) -> Tuple[EXSTRBYTES, ...]: ...
async def hash_files_threads(*filenames: Union[str, Path], algo: str=..., b64: Any=..., hexdigest: Any=..., fail: Any=..., **kwargs: Any) -> Tuple[EXSTRBYTES, ...]: ...
