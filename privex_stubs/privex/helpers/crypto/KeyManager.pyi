from cryptography.hazmat.primitives.hashes import HashAlgorithm
from cryptography.hazmat.primitives.serialization import Encoding, PrivateFormat, PublicFormat
from io import BufferedWriter, TextIOWrapper
from privex.helpers.common import byteify as byteify, empty as empty, stringify as stringify
from privex.helpers.crypto.base import auto_b64decode as auto_b64decode, is_base64 as is_base64
from privex.helpers.exceptions import EncryptionError as EncryptionError, InvalidFormat as InvalidFormat
from typing import Any, Optional, Tuple, Union

log: Any
Text = Union[str, bytes]

class Format:
    public_formats: Any = ...
    private_formats: Any = ...
    encodings: Any = ...
    private_format: PrivateFormat
    public_format: PublicFormat
    public_encoding: Encoding
    private_encoding: Encoding
    def __init__(self, private_format: Any, private_encoding: Any, public_format: str = ..., public_encoding: str = ...) -> None: ...
    @classmethod
    def get_format(cls: Any, fmtype: Any, key: Any) -> Union[Encoding, PublicFormat, PrivateFormat]: ...

class KeyManager:
    backend: Any = ...
    default_gen: Any = ...
    Format: Any = ...
    default_formats: Any = ...
    generators: Any = ...
    curves: Any = ...
    private_key_types: Any = ...
    public_key_types: Any = ...
    combined_key_types: Any = ...
    raw_pub_types: Any = ...
    raw_priv_types: Any = ...
    public_key: Optional[public_key_types]
    private_key: Optional[private_key_types]
    type_name_map: Any = ...
    def __init__(self, key: Union[Text, private_key_types, public_key_types], password: Text=...) -> None: ...
    def sign(self, message: Text, pad: Any=..., hashing: HashAlgorithm=...) -> bytes: ...
    def verify(self, signature: Text, message: Text, pad: Any=..., hashing: HashAlgorithm=...) -> bool: ...
    def encrypt(self, message: Text, pad: Any=..., hashing: HashAlgorithm=...) -> bytes: ...
    def decrypt(self, message: Text, pad: Any=..., hashing: HashAlgorithm=...) -> bytes: ...
    @classmethod
    def identify_algorithm(cls: Any, key: combined_key_types) -> str: ...
    def export_public(self, **kwargs: Any) -> bytes: ...
    def export_private(self, **kwargs: Any) -> bytes: ...
    @classmethod
    def load_key(cls: Any, data: Text, password: bytes=...) -> Tuple[combined_key_types, str]: ...
    @classmethod
    def load_keyfile(cls: Any, filename: Text, password: Text=...) -> Any: ...
    @classmethod
    def generate_keypair_raw(cls: Any, alg: Any=..., **kwargs: Any) -> Tuple[private_key_types, public_key_types]: ...
    @classmethod
    def generate_keypair(cls: Any, alg: Any=..., **kwargs: Any) -> Tuple[bytes, bytes]: ...
    @classmethod
    def export_key(cls: Any, key: combined_key_types, **kwargs: Any) -> bytes: ...
    @classmethod
    def output_keypair(cls: Any, priv: Union[str, BufferedWriter], pub: Union[str, TextIOWrapper], *args: Any, **kwargs: Any) -> Tuple[bytes, bytes]: ...
