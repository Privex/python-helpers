from privex.helpers.cache.asyncx import *
from privex.helpers import plugin as plugin
from privex.helpers.asyncx import await_if_needed as await_if_needed, awaitable as awaitable, loop_run as loop_run
from privex.helpers.cache.CacheAdapter import CacheAdapter as CacheAdapter
from privex.helpers.cache.MemcachedCache import MemcachedCache as MemcachedCache
from privex.helpers.cache.MemoryCache import MemoryCache as MemoryCache
from privex.helpers.cache.RedisCache import RedisCache as RedisCache
from privex.helpers.cache.SqliteCache import SqliteCache as SqliteCache
from privex.helpers.collections import DictObject as DictObject
from privex.helpers.common import LayeredContext as LayeredContext, empty_if as empty_if
from privex.helpers.exceptions import CacheNotFound as CacheNotFound, NotConfigured as NotConfigured
from privex.helpers.settings import DEFAULT_CACHE_TIMEOUT as DEFAULT_CACHE_TIMEOUT
from typing import Any, Optional, Type, Union

log: Any
__STORE: Any
CLSCacheAdapter = Union[Type[CacheAdapter], Type[AsyncCacheAdapter]]
INSCacheAdapter = Union[CacheAdapter, AsyncCacheAdapter]
ANYCacheAdapter = Union[CLSCacheAdapter, INSCacheAdapter]
ADAPTER_MAP: Any
_AM = ADAPTER_MAP

def import_adapter_path(full_path: str) -> Type[Union[CacheAdapter, AsyncCacheAdapter]]: ...
def import_adapter(name: str, cat: str=..., fallback_shared: Any=...) -> Type[Union[CacheAdapter, AsyncCacheAdapter]]: ...

class CacheWrapper:
    cache_instance: Optional[INSCacheAdapter] = ...
    default_adapter: Type[CLSCacheAdapter] = ...
    instance_args: Any = ...
    instance_kwargs: Any = ...
    max_context_layers: int = ...
    _ctx_tracker: Optional[LayeredContext] = ...
    @classmethod
    def get_context_tracker(cls: Any, reset: bool=...) -> LayeredContext: ...
    @classmethod
    def reset_context_tracker(cls: Any) -> LayeredContext: ...
    @classmethod
    def get_adapter(cls: Any, default: CLSCacheAdapter=..., *args: Any, **kwargs: Any) -> INSCacheAdapter: ...
    @classmethod
    def set_adapter(cls: Any, adapter: ANYCacheAdapter, *args: Any, **kwargs: Any) -> INSCacheAdapter: ...
    @classmethod
    def reset_adapter(cls: Any, default: CLSCacheAdapter=..., *args: Any, **kwargs: Any) -> INSCacheAdapter: ...
    def __getattr__(self, item: Any): ...
    def __getitem__(self, item: Any): ...
    def __setitem__(self, key: Any, value: Any): ...
    async def __aenter__(self): ...
    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any): ...
    def __enter__(self): ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any): ...

cached: Union[CacheAdapter, CacheWrapper]

class AsyncCacheWrapper(CacheWrapper):
    cache_instance: AsyncCacheAdapter = ...
    instance_args: Any = ...
    instance_kwargs: Any = ...
    default_adapter: Type[AsyncCacheAdapter] = ...
    max_context_layers: int = ...
    _ctx_tracker: Optional[LayeredContext] = ...
    @classmethod
    def get_adapter(cls: Any, default: Type[AsyncCacheAdapter]=..., *args: Any, **kwargs: Any) -> AsyncCacheAdapter: ...
    @classmethod
    def set_adapter(cls: Any, adapter: AsyncCacheAdapter, *args: Any, **kwargs: Any) -> AsyncCacheAdapter: ...
    @classmethod
    def reset_adapter(cls: Any, default: Type[AsyncCacheAdapter]=..., *args: Any, **kwargs: Any) -> AsyncCacheAdapter: ...
    def __getattr__(self, item: Any): ...
    def __getitem__(self, item: Any): ...
    def __setitem__(self, key: Any, value: Any): ...
    def __enter__(self): ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any): ...

async_cached: Union[AsyncCacheAdapter, AsyncCacheWrapper]

def async_adapter_set(adapter: Union[AsyncCacheAdapter, str]) -> AsyncCacheAdapter: ...
def async_adapter_get(default: Union[Type[AsyncCacheAdapter], str]=...) -> AsyncCacheAdapter: ...
def adapter_set(adapter: Union[CacheAdapter, str]) -> CacheAdapter: ...
def adapter_get(default: Union[Type[CacheAdapter], str]=...) -> CacheAdapter: ...
def get(key: str, default: Any=..., fail: bool=...) -> Any: ...
def set(key: str, value: Any, timeout: Optional[int]=...) -> Any: ...
def get_or_set(key: str, value: Union[Any, callable], timeout: int=...) -> Any: ...
def remove(*key: str) -> bool: ...
def update_timeout(key: str, timeout: int=...) -> Any: ...
