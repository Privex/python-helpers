from .asyncx import *
from privex.helpers import plugin as plugin
from privex.helpers.asyncx import await_if_needed as await_if_needed, awaitable as awaitable, loop_run as loop_run
from .CacheAdapter import CacheAdapter as CacheAdapter
from .MemoryCache import MemoryCache as MemoryCache
from .RedisCache import RedisCache as RedisCache
from .SqliteCache import SqliteCache as SqliteCache
from privex.helpers.common import LayeredContext as LayeredContext, empty_if as empty_if
from privex.helpers.exceptions import CacheNotFound as CacheNotFound, NotConfigured as NotConfigured
from privex.helpers.settings import DEFAULT_CACHE_TIMEOUT as DEFAULT_CACHE_TIMEOUT
from typing import Any, Optional, Type, Union

log: Any
CLSCacheAdapter = Union[Type[CacheAdapter], Type[AsyncCacheAdapter]]
INSCacheAdapter = Union[CacheAdapter, AsyncCacheAdapter]
ANYCacheAdapter = Union[CLSCacheAdapter, INSCacheAdapter]

class CacheWrapper:
    cache_instance: Optional[INSCacheAdapter] = ...
    default_adapter: Type[CLSCacheAdapter] = ...
    instance_args: Any = ...
    instance_kwargs: Any = ...
    max_context_layers: int = ...
    @classmethod
    def get_context_tracker(cls: Any, reset: bool=...) -> LayeredContext: ...
    @classmethod
    def reset_context_tracker(cls: Any) -> LayeredContext: ...
    @classmethod
    def get_adapter(cls: Any, default: CLSCacheAdapter=..., *args: Any, **kwargs: Any) -> INSCacheAdapter: ...
    @classmethod
    def set_adapter(cls: Any, adapter: ANYCacheAdapter, *args: Any, **kwargs: Any) -> INSCacheAdapter: ...
    @classmethod
    def reset_adapter(cls: Any, default: CLSCacheAdapter=..., *args: Any, **kwargs: Any) -> INSCacheAdapter: ...
    def __getattr__(self, item: Any): ...
    def __getitem__(self, item: Any): ...
    def __setitem__(self, key: Any, value: Any): ...
    async def __aenter__(self): ...
    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any): ...
    def __enter__(self): ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any): ...

cached: Union[CacheAdapter, CacheWrapper]

class AsyncCacheWrapper(CacheWrapper):
    cache_instance: AsyncCacheAdapter = ...
    instance_args: Any = ...
    instance_kwargs: Any = ...
    default_adapter: Type[AsyncCacheAdapter] = ...
    max_context_layers: int = ...
    @classmethod
    def get_adapter(cls: Any, default: Type[AsyncCacheAdapter]=..., *args: Any, **kwargs: Any) -> AsyncCacheAdapter: ...
    @classmethod
    def set_adapter(cls: Any, adapter: AsyncCacheAdapter, *args: Any, **kwargs: Any) -> AsyncCacheAdapter: ...
    @classmethod
    def reset_adapter(cls: Any, default: Type[AsyncCacheAdapter]=..., *args: Any, **kwargs: Any) -> AsyncCacheAdapter: ...
    def __getattr__(self, item: Any): ...
    def __getitem__(self, item: Any): ...
    def __setitem__(self, key: Any, value: Any): ...
    def __enter__(self): ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any): ...

async_cached: Union[AsyncCacheAdapter, AsyncCacheWrapper]

def async_adapter_set(adapter: AsyncCacheAdapter) -> AsyncCacheAdapter: ...
def async_adapter_get(default: Type[AsyncCacheAdapter]=...) -> AsyncCacheAdapter: ...
def adapter_set(adapter: CacheAdapter) -> Any: ...
def adapter_get(default: Type[CacheAdapter]=...) -> CacheAdapter: ...
def get(key: str, default: Any=..., fail: bool=...) -> Any: ...
def set(key: str, value: Any, timeout: Optional[int]=...) -> Any: ...
def get_or_set(key: str, value: Union[Any, callable], timeout: int=...) -> Any: ...
def remove(*key: str) -> bool: ...
def update_timeout(key: str, timeout: int=...) -> Any: ...
