import abc
from abc import ABC, abstractmethod
from privex.helpers.asyncx import await_if_needed as await_if_needed
from privex.helpers.common import empty_if as empty_if
from privex.helpers.exceptions import CacheNotFound as CacheNotFound
from privex.helpers.settings import DEFAULT_CACHE_TIMEOUT as DEFAULT_CACHE_TIMEOUT
from privex.helpers.types import VAL_FUNC_CORO as VAL_FUNC_CORO
from typing import Any, Optional, Union

class CacheAdapter(ABC, metaclass=abc.ABCMeta):
    adapter_enter_reconnect: bool = ...
    adapter_exit_close: bool = ...
    ins_enter_reconnect: bool
    ins_exit_close: bool
    def __init__(self, *args: Any, enter_reconnect: Optional[bool]=..., exit_close: Optional[bool]=..., **kwargs: Any) -> None: ...
    @abstractmethod
    def get(self, key: str, default: Any=..., fail: bool=...) -> Any: ...
    @abstractmethod
    def set(self, key: str, value: Any, timeout: Optional[int]=...) -> Any: ...
    @abstractmethod
    def remove(self, *key: str) -> bool: ...
    @abstractmethod
    def update_timeout(self, key: str, timeout: int=...) -> Any: ...
    def get_or_set(self, key: str, value: Union[Any, callable], timeout: int=...) -> Any: ...
    async def get_or_set_async(self, key: str, value: VAL_FUNC_CORO, timeout: int=...) -> Any: ...
    def close(self, *args: Any, **kwargs: Any) -> Any: ...
    def connect(self, *args: Any, **kwargs: Any) -> Any: ...
    def reconnect(self, *args: Any, **kwargs: Any) -> Any: ...
    def __getitem__(self, item: Any): ...
    def __setitem__(self, key: Any, value: Any): ...
    async def __aenter__(self): ...
    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
