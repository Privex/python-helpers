from privex.helpers import settings as settings
from privex.helpers.cache.CacheAdapter import CacheAdapter as CacheAdapter
from privex.helpers.common import empty as empty, empty_if as empty_if, is_true as is_true
from privex.helpers.exceptions import CacheNotFound as CacheNotFound
from typing import Any, Optional

from privex.helpers.cache.post_deps import SqliteCacheManager, SqliteCacheResult

log: Any


def _cache_result_expired(res: SqliteCacheResult, _auto_purge=True) -> bool: ...


class SqliteCache(CacheAdapter):
    pickle_default: bool = ...
    use_pickle: bool
    last_purged_expired: Optional[int] = ...
    db_file: Any = ...
    db_folder: Any = ...
    connection_kwargs: Any = ...
    memory_persist: Any = ...
    purge_every: Any = ...
    _wrapper: Optional[SqliteCacheManager] = ...
    
    def __init__(self, db_file: str=..., memory_persist: Any=..., use_pickle: bool=..., connection_kwargs: dict=..., *args: Any, **kwargs: Any) -> None: ...
    
    @property
    def purge_due(self) -> bool: ...
    
    @property
    def wrapper(self) -> SqliteCacheManager: ...
    
    def purge_expired(self, force: Any=...) -> Optional[int]: ...
    def get(self, key: str, default: Any=..., fail: bool=..., _auto_purge: Any=...) -> Any: ...
    def set(self, key: str, value: Any, timeout: Optional[int]=..., _auto_purge: Any=...) -> Any: ...
    def remove(self, *key: str) -> bool: ...
    def update_timeout(self, key: str, timeout: int=...) -> Any: ...
    def connect(self, db: Any=..., *args: Any, connection_kwargs: Any=..., memory_persist: Any=..., **kwargs: Any) -> SqliteCacheManager: ...
    def close(self) -> None: ...
