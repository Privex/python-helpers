import threading
from privex.helpers.black_magic import caller_name as caller_name
from privex.helpers.cache import CacheNotFound as CacheNotFound, cached as cached
from privex.helpers.common import DictObject as DictObject, auto_list as auto_list, empty as empty, empty_if as empty_if
from privex.helpers.decorators import FO as FO, r_cache as r_cache
from privex.helpers.thread import lock_acquire_timeout as lock_acquire_timeout
from privex.helpers.types import AUTO as AUTO, AnyNum as AnyNum
from time import sleep as sleep
from typing import Any, Callable, ContextManager, Optional, Set, Type, Union

log: Any
CACHE_MGR: Any
NO_LOCK: Any
ANY_LCK = Optional[Union[threading.Lock, Type[NO_LOCK]]]

def fake_lock_manager(lock: threading.Lock=..., *args: Any, **kwargs: Any) -> Any: ...

class CacheSettings:
    cache_prefix: str = ...
    cache_key_log_name: str = ...
    cache_sep: str = ...
    default_cache_key_time: Union[float, int] = ...
    default_cache_time: Union[float, int] = ...
    _gen_cache_key: Callable[[Any], str] = ...
    _key_add_prefix: Callable[[Any], str] = ...
    def gen_cache_key(self, *args: Any, _auto_cache: Any=..., _comps_start: list=..., _comps_end: list=..., **query: Any) -> str: ...
    def key_add_prefix(self, key: Union[str, Callable[[Any], str]], auto_prefix: bool=..., _auto_cache: Any=..., call_args: list=..., call_kwargs: dict=..., _lock: ANY_LCK=...) -> str: ...
    @classmethod
    def from_class(cls: Any, obj: Union[CacheManagerMixin, Type[CacheManagerMixin]]) -> CacheSettings: ...
    def __init__(self, cache_prefix: Any, cache_key_log_name: Any, cache_sep: Any, default_cache_key_time: Any, default_cache_time: Any, gen_cache_key: Any, key_add_prefix: Any) -> None: ...
    def __lt__(self, other: Any) -> Any: ...
    def __le__(self, other: Any) -> Any: ...
    def __gt__(self, other: Any) -> Any: ...
    def __ge__(self, other: Any) -> Any: ...

def z_cache(cls: CACHE_MGR=..., cache_key: Union[str, callable]=..., cache_time: Any=..., format_args: list=..., format_opt: FO=..., extract_class: Any=..., **opts: Any) -> Any: ...

class CacheManagerMixin:
    cache_key_lock: Optional[threading.Lock] = ...
    cache_prefix: str = ...
    cache_key_log_name: str = ...
    cache_sep: str = ...
    default_cache_key_time: Union[float, int] = ...
    default_cache_time: Union[float, int] = ...
    @classmethod
    def _get_lock(cls: Any, lock: ANY_LCK=..., timeout: Any=..., fail: Any=...) -> ContextManager: ...
    @classmethod
    def gen_cache_key(cls: Any, *args: Any, _auto_cache: Any=..., _comps_start: list=..., _comps_end: list=..., **query: Any) -> str: ...
    @classmethod
    def get_all_cache_keys(cls: Any) -> Set[str]: ...
    @classmethod
    def log_cache_key(cls: Any, key: str, _lock: ANY_LCK=...) -> Set[str]: ...
    @classmethod
    def log_delete_cache_keys(cls: Any, *ckeys: str, _lock: ANY_LCK=...) -> Set[str]: ...
    log_delete_cache_key: Any = ...
    @classmethod
    def cache_set(cls: Any, key: str, value: Any, timeout: Optional[AnyNum]=..., auto_prefix: bool=...) -> Any: ...
    @classmethod
    def cache_get(cls: Any, key: str, default: Any=..., fail: bool=..., auto_prefix: Any=..., fallback_prefix: bool=...) -> Any: ...
    @classmethod
    def cache_get_or_set(cls: Any, key: str, value: Any, timeout: Optional[AnyNum]=..., auto_prefix: Any=...) -> Any: ...
    @classmethod
    def _pfx_key(cls: Any, key: Union[str, Callable[[Any], str]], auto_prefix: bool=..., _auto_cache: Any=..., call_args: list=..., call_kwargs: dict=..., _lock: ANY_LCK=...) -> str: ...
    key_add_prefix: Any = ...
    @classmethod
    def _unpfx_key(cls: Any, key: str, prefix: str=..., sep: str=...) -> Any: ...
    key_remove_prefix: Any = ...
    @classmethod
    def clear_cache_keys(cls: Any, *keys: str, auto_prefix: Any=..., remove_log: Any=..., _lock: ANY_LCK=...) -> bool: ...
    @classmethod
    def clear_all_cache_keys(cls): ...
