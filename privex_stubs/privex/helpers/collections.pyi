from collections import OrderedDict, namedtuple
from dataclasses import dataclass, field
from enum import Enum
from privex.helpers.types import AUTO as AUTO, K as K, T as T
from typing import Any, Callable, Dict, Generator, Iterable, List, NamedTuple, Optional, Type, Union

log: Any

def _mock_decorator(*dec_args: Any, **dec_kwargs: Any): ...
def generate_class(name: str, qualname: str=..., module: str=..., bases: Union[tuple, list]=..., attributes: Dict[str, Any]=..., **kwargs: Any) -> Any: ...
def generate_class_kw(name: str, qualname: str=..., module: str=..., bases: Union[tuple, list]=..., **kwargs: Any) -> Type: ...
def copy_func(f: Callable, rewrap_classmethod: Any=..., name: Any=..., qualname: Any=..., module: Any=..., **kwargs: Any) -> Union[Callable, classmethod]: ...
def _q_copy(obj: K, key: str=..., deep_private: bool=..., quiet: bool=..., fail: bool=..., **kwargs: Any) -> K: ...

COPY_CLASS_BLACKLIST: Any

def _copy_class_dict(obj: Type[T], name: Any, deep_copy: Any=..., deep_private: Any=..., **kwargs: Any) -> Union[Type[T], type]: ...
def _copy_class_slotted(obj: Type[T], name: Any, deep_copy: Any=..., deep_private: Any=..., **kwargs: Any) -> Union[Type[T], type]: ...

DEFAULT_ALLOWED_DUPE: Any

def copy_class_simple(obj: Type[T], name: Any=..., qualname: Any=..., module: Any=..., allow_attrs: list=..., ban_attrs: list=..., **kwargs: Any) -> Any: ...
def copy_class(obj: Type[T], name: Any=..., deep_copy: Any=..., deep_private: Any=..., **kwargs: Any) -> Union[Type[T], type]: ...
def _create_mocker_copy(name: Any=..., **kwargs: Any) -> Union[type, Type[Mocker]]: ...

class Mocker:
    mock_modules: dict
    mock_attrs: dict
    def __init__(self, modules: dict=..., attributes: dict=..., *args: Any, **kwargs: Any) -> None: ...
    @classmethod
    def make_mock_module(cls: Any, mod_name: str, attributes: dict=..., modules: dict=..., built_in: Any=..., **kwargs: Any) -> Any: ...
    @classmethod
    def make_mock_class(cls: Any, name: Any=..., instance: Any=..., simple: Any=..., attributes: dict=..., modules: dict=..., **kwargs: Any) -> Union[Any, Mocker, Type[Mocker]]: ...
    def add_mock_module(self, name: str, value: Any=..., mock_attrs: dict=..., mock_modules: dict=...) -> Any: ...
    def add_mock_modules(self, *module_list: Any, _dict_to_attrs: bool = ..., _parse_dict: bool = ..., **module_map: Any) -> None: ...
    @classmethod
    def _duplicate_cls(cls: Any, name: Any=..., qualname: Any=..., module: Any=..., **kwargs: Any) -> Type[Mocker]: ...
    def _duplicate_ins(self, name: Any=..., qualname: Any=..., module: Any=..., **kwargs: Any) -> Mocker: ...
    def __getattr__(self, item: Any): ...
    def __setattr__(self, key: Any, value: Any): ...
    def __getitem__(self, item: Any): ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    @property
    def __name__(self): ...
    def __dir__(self) -> Iterable[str]: ...

def _module_dir(): ...

dataclasses_mock: Any
dataclasses = dataclasses_mock
dataclass = dataclass
field = field

class DictObject(dict):
    def __getattr__(self, item: Any): ...
    def __setattr__(self, key: Any, value: Any): ...
    def __dir__(self) -> Iterable[str]: ...

class OrderedDictObject(OrderedDict):
    def __getattr__(self, item: Any): ...
    def __setattr__(self, key: Any, value: Any): ...
    def __dir__(self) -> Iterable[str]: ...

class MockDictObj(DictObject): ...

def is_namedtuple(*objs: Any) -> bool: ...
def convert_dictable_namedtuple(nt_instance: Any, typename: Any=..., module: Any=..., **kwargs: Any) -> Union[NamedTuple, Dict]: ...
def subclass_dictable_namedtuple(named_type: type, typename: Any=..., module: Any=..., **kwargs: Any) -> type: ...
def make_dict_tuple(typename: Any, field_names: Any, *args: Any, **kwargs: Any): ...
def dictable_namedtuple(typename: Any, field_names: Any, *args: Any, **kwargs: Any) -> Union[Type[namedtuple], dict]: ...

class Dictable:
    def __iter__(self) -> Any: ...
    def __getitem__(self, key: Any): ...
    def __setitem__(self, key: Any, value: Any): ...
    def get(self, key: Any, fallback: Any=...) -> Any: ...
    @classmethod
    def from_dict(cls: Union[Type[Dictable], Type[T]], env: Any) -> T: ...
    @classmethod
    def from_list(cls: Type[T], obj_list: Iterable[dict]) -> Generator[T, None, None]: ...

def _iter_attr_to_dict(obj: Any, xattrs: Iterable[Any], check_attrs: Any=..., strip_private: Any=...) -> dict: ...
def _ispriv(key: str) -> bool: ...
AnyTypeObj = Union[Type[Any], object, Any]
ObjToDictFunc = Callable[[AnyTypeObj, bool], dict]
INST_DICT_MAP: Dict[str, ObjToDictFunc]

class ObjDictEnum(Enum):
    dict: str = ...
    DICT: str = ...
    slots: str = ...
    SLOTS: str = ...
    dir: str = ...
    DIR: str = ...
    iter: str = ...
    ITER: str = ...

def dump_obj(obj: AnyTypeObj, conv: Union[str, ObjDictEnum, ObjToDictFunc]=..., strip_private: bool=...) -> dict: ...

class DictDataClass(Dictable):
    raw_data: Union[dict, DictObject]
    class _DictConfig:
        dict_convert_mode: Optional[str] = ...
        dict_listify: List[str] = ...
        listify_cast: Union[Type, callable] = ...
        dict_exclude_base: List[str] = ...
        dict_exclude: List[str] = ...
    @property
    def _dc_dict_config(self) -> Union[_DictConfig, DictObject]: ...
    DictConfig: Any = ...
    def __iter__(self) -> Any: ...
    def __getitem__(self, key: Any): ...
    def __setitem__(self, key: Any, value: Any): ...
    def __getattr__(self, item: Any): ...
    def __setattr__(self, key: Any, value: Any): ...
    @classmethod
    def from_dict(cls: Union[Type[dataclass], Type[T]], obj: Any) -> T: ...
    @classmethod
    def from_special(cls: Union[Type[dataclass], Type[T]], obj: AnyTypeObj, conv: Union[str, ObjToDictFunc, ObjDictEnum]=..., strip_private: bool=..., **kwargs: Any) -> T: ...
    @classmethod
    def from_object(cls: Union[Type[dataclass], Type[T]], obj: Union[Type[Any], object], strip_private: Any=...) -> T: ...
DictDataclass = DictDataClass
